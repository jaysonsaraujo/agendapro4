<?php
/**
 * MessageProcessor.php
 * 
 * Respons√°vel por processar e formatar mensagens do WhatsApp.
 * Extrai conte√∫do, identifica tipos de mensagem e faz an√°lise inicial.
 */

class MessageProcessor {
    /**
     * Processa o conte√∫do da mensagem recebida.
     * 
     * @param array $messageData Dados da mensagem do WhatsApp
     * @return array Informa√ß√µes da mensagem processada
     */
    public function processMessageData($messageData) {
        if (empty($messageData['key'])) {
            return [
                'success' => false,
                'message' => 'Dados da mensagem inv√°lidos'
            ];
        }

        try {
            // Extrair informa√ß√µes da mensagem
            $remoteJid = $messageData['key']['remoteJid'];
            $fromMe = $messageData['key']['fromMe'] ?? false;
            $messageId = $messageData['key']['id'];

            // Se a mensagem for do pr√≥prio bot, ignorar
            if ($fromMe) {
                return [
                    'success' => true,
                    'processed' => false,
                    'message' => 'Mensagem do bot ignorada'
                ];
            }

            // Extrair o conte√∫do e tipo da mensagem
            $extractedData = $this->extractMessageContent($messageData['message'] ?? []);
            
            return [
                'success' => true,
                'processed' => true,
                'remoteJid' => $remoteJid,
                'messageId' => $messageId,
                'content' => $extractedData['content'],
                'type' => $extractedData['type']
            ];
        } catch (Exception $e) {
            error_log("Erro ao processar dados da mensagem: " . $e->getMessage());
            return [
                'success' => false,
                'message' => "Erro ao processar dados da mensagem: " . $e->getMessage()
            ];
        }
    }

    /**
     * Extrai o conte√∫do da mensagem com base no tipo
     * 
     * @param array $message Objeto de mensagem do WhatsApp
     * @return array Conte√∫do e tipo da mensagem
     */
    public function extractMessageContent($message) {
        // Determinar o tipo de mensagem
        $messageType = $this->determineMessageType($message);
        
        // Extrair conte√∫do baseado no tipo
        if ($messageType === 'text') {
            if (isset($message['conversation']) && !empty($message['conversation'])) {
                return ['content' => $message['conversation'], 'type' => 'text'];
            }
            
            if (isset($message['extendedTextMessage']) && !empty($message['extendedTextMessage']['text'])) {
                return ['content' => $message['extendedTextMessage']['text'], 'type' => 'text'];
            }
        } else {
            // Retornar informa√ß√£o do tipo de m√≠dia
            return ['content' => null, 'type' => $messageType];
        }

        // Mensagem vazia ou tipo n√£o suportado
        return ['content' => null, 'type' => 'unknown'];
    }
    
    /**
     * Determina o tipo de mensagem
     * 
     * @param array $message Objeto de mensagem do WhatsApp
     * @return string Tipo da mensagem
     */
    public function determineMessageType($message) {
        if (isset($message['conversation']) || isset($message['extendedTextMessage'])) {
            return 'text';
        }
        
        if (isset($message['imageMessage'])) {
            return 'image';
        }
        
        if (isset($message['audioMessage'])) {
            return 'audio';
        }
        
        if (isset($message['videoMessage'])) {
            return 'video';
        }
        
        if (isset($message['documentMessage'])) {
            return 'document';
        }
        
        if (isset($message['stickerMessage'])) {
            return 'sticker';
        }
        
        if (isset($message['locationMessage'])) {
            return 'location';
        }
        
        if (isset($message['contactMessage']) || isset($message['contactsArrayMessage'])) {
            return 'contact';
        }
        
        return 'unknown';
    }
    
    /**
     * Gera mensagem de resposta para tipos de m√≠dia n√£o process√°veis
     * 
     * @param string $messageType Tipo de mensagem
     * @return string Mensagem de resposta
     */
    public function getMediaTypeResponse($messageType) {
        switch($messageType) {
            case 'audio':
                return "Ol√°! Percebi que voc√™ enviou um √°udio. Por enquanto, s√≥ consigo processar mensagens de texto. Por favor, digite sua mensagem para que eu possa te ajudar melhor! üòä";
            case 'image':
                return "Ol√°! Vi que voc√™ enviou uma imagem. Infelizmente, s√≥ consigo processar mensagens de texto no momento. Por favor, digite sua d√∫vida ou solicita√ß√£o para que eu possa te ajudar! üìù";
            case 'video':
                return "Ol√°! Percebi que voc√™ enviou um v√≠deo. Atualmente, s√≥ consigo processar mensagens de texto. Por favor, digite sua mensagem para que eu possa te ajudar! üí¨";
            case 'document':
                return "Ol√°! Vi que voc√™ enviou um documento. Por enquanto, s√≥ consigo processar mensagens de texto. Por favor, digite sua d√∫vida ou solicita√ß√£o para que eu possa te ajudar! üìù";
            case 'sticker':
                return "Ol√°! Vi que voc√™ enviou um sticker. Que tal me enviar uma mensagem de texto para que eu possa te ajudar melhor? üòä";
            case 'location':
                return "Ol√°! Percebi que voc√™ compartilhou uma localiza√ß√£o. Por enquanto, s√≥ consigo processar mensagens de texto. Por favor, me explique em texto como posso te ajudar! üó∫Ô∏è";
            case 'contact':
                return "Ol√°! Vi que voc√™ compartilhou um contato. Atualmente, s√≥ consigo processar mensagens de texto. Por favor, digite sua solicita√ß√£o para que eu possa te ajudar! üìû";
            default:
                return "Ol√°! Notei que voc√™ enviou um tipo de mensagem que n√£o consigo processar. Por favor, envie sua mensagem como texto para que eu possa te ajudar melhor! üôÇ";
        }
    }
    
    /**
     * Verifica se a mensagem cont√©m uma inten√ß√£o espec√≠fica
     * 
     * @param string $message Mensagem do usu√°rio
     * @param array $keywords Palavras-chave para verificar
     * @return bool Verdadeiro se a mensagem cont√©m a inten√ß√£o
     */
    public function hasIntent($message, $keywords) {
        $message = mb_strtolower(trim($message));
        
        foreach ($keywords as $keyword) {
            if (strpos($message, $keyword) !== false) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Analisa a mensagem do usu√°rio para identificar a inten√ß√£o inicial
     * 
     * @param string $message Mensagem do usu√°rio
     * @return array Informa√ß√µes da inten√ß√£o identificada
     */
    public function analyzeInitialIntent($message) {
        $message = mb_strtolower(trim($message));
        $result = [
            'intent' => 'unknown',
            'entity' => null,
            'parameters' => []
        ];
        
        // Verificar sauda√ß√µes
        $greetings = ['oi', 'ol√°', 'ola', 'bom dia', 'boa tarde', 'boa noite', 'ei', 'hey'];
        foreach ($greetings as $greeting) {
            if (strpos($message, $greeting) !== false) {
                $result['intent'] = 'greeting';
                return $result;
            }
        }
        
        // Verificar inten√ß√£o de agendamento com servi√ßo espec√≠fico
        if (preg_match('/(quero|desejo|preciso|gostaria|pode|posso|vou|preciso)\s+(de\s+)?(marcar|agendar|fazer|reservar)\s+(um|uma)?\s*([\w\s]+?)(?:\s+para|$|\s*\?)/ui', $message, $matches)) {
            $service = mb_strtolower(trim($matches[5]));
            $result['intent'] = 'scheduling';
            $result['entity'] = 'service';
            $result['parameters']['service'] = $service;
            return $result;
        }
        
        // Verificar inten√ß√£o de agendamento gen√©rica
        if (preg_match('/(quero|desejo|preciso|gostaria|pode|posso|vou|preciso)\s+(de\s+)?(marcar|agendar|fazer|reservar)/ui', $message)) {
            $result['intent'] = 'scheduling';
            return $result;
        }
        
        // Verificar consulta de servi√ßos
        if (preg_match('/(quais|que|ver|saber|mostrar|listar)\s+(os\s+)?(servi√ßos|servicos|procedimentos|tratamentos)/ui', $message)) {
            $result['intent'] = 'list_services';
            return $result;
        }
        
        // Verificar consulta de hor√°rios
        if (preg_match('/(hor√°rios|horarios|horas|agenda|disponibilidade|dispon√≠vel|disponivel)/ui', $message)) {
            $result['intent'] = 'check_availability';
            return $result;
        }
        
        // Verificar consulta de agendamentos
        if (preg_match('/(meus|meu|ver|consultar|mostrar)\s+(agendamentos?|hor√°rios?|horarios?|compromissos?)/ui', $message)) {
            $result['intent'] = 'check_appointments';
            return $result;
        }
        
        // Verificar inten√ß√£o de cancelamento
        if (preg_match('/(cancelar|desmarcar|remover)\s+(agendamento|hor√°rio|horario|compromisso)/ui', $message)) {
            $result['intent'] = 'cancel_appointment';
            return $result;
        }
        
        return $result;
    }
    
    /**
     * Extrai informa√ß√µes de data de uma mensagem
     * 
     * @param string $message Mensagem do usu√°rio
     * @return array Informa√ß√µes de data extra√≠das
     */
    public function extractDateInfo($message) {
        $message = mb_strtolower(trim($message));
        $result = [
            'found' => false,
            'date' => null,
            'formatted_date' => null,
            'day_of_week' => null
        ];
        
        // Padr√µes de data
        $patterns = [
            // DD/MM/YYYY
            '/(\d{1,2})\/(\d{1,2})\/(\d{4})/' => function($matches) {
                return sprintf('%04d-%02d-%02d', $matches[3], $matches[2], $matches[1]);
            },
            // DD/MM
            '/(\d{1,2})\/(\d{1,2})(?!\/)/' => function($matches) {
                $year = date('Y');
                return sprintf('%04d-%02d-%02d', $year, $matches[2], $matches[1]);
            },
            // DD de M√™s
            '/(\d{1,2})\s+de\s+(janeiro|fevereiro|mar√ßo|marco|abril|maio|junho|julho|agosto|setembro|outubro|novembro|dezembro)/' => function($matches) {
                $months = [
                    'janeiro' => 1, 'fevereiro' => 2, 'mar√ßo' => 3, 'marco' => 3,
                    'abril' => 4, 'maio' => 5, 'junho' => 6, 'julho' => 7,
                    'agosto' => 8, 'setembro' => 9, 'outubro' => 10,
                    'novembro' => 11, 'dezembro' => 12
                ];
                $day = $matches[1];
                $month = $months[$matches[2]];
                $year = date('Y');
                
                return sprintf('%04d-%02d-%02d', $year, $month, $day);
            }
        ];
        
        // Express√µes relativas de data
        $relative_dates = [
            'hoje' => '+0 day',
            'amanh√£' => '+1 day',
            'amanha' => '+1 day',
            'depois de amanh√£' => '+2 days',
            'depois de amanha' => '+2 days',
            'pr√≥xima segunda' => 'next monday',
            'proxima segunda' => 'next monday',
            'pr√≥xima ter√ßa' => 'next tuesday',
            'proxima terca' => 'next tuesday',
            'pr√≥xima quarta' => 'next wednesday',
            'proxima quarta' => 'next wednesday',
            'pr√≥xima quinta' => 'next thursday',
            'proxima quinta' => 'next thursday',
            'pr√≥xima sexta' => 'next friday',
            'proxima sexta' => 'next friday',
            'pr√≥ximo s√°bado' => 'next saturday',
            'proximo sabado' => 'next saturday',
            'pr√≥ximo domingo' => 'next sunday',
            'proximo domingo' => 'next sunday'
        ];
        
        // Verificar padr√µes de data
        foreach ($patterns as $pattern => $formatter) {
            if (preg_match($pattern, $message, $matches)) {
                $result['found'] = true;
                $result['date'] = $formatter($matches);
                $timestamp = strtotime($result['date']);
                $result['formatted_date'] = date('d/m/Y', $timestamp);
                $result['day_of_week'] = date('w', $timestamp);
                return $result;
            }
        }
        
        // Verificar express√µes relativas
        foreach ($relative_dates as $expression => $modifier) {
            if (strpos($message, $expression) !== false) {
                $result['found'] = true;
                $timestamp = strtotime($modifier);
                $result['date'] = date('Y-m-d', $timestamp);
                $result['formatted_date'] = date('d/m/Y', $timestamp);
                $result['day_of_week'] = date('w', $timestamp);
                return $result;
            }
        }
        
        // Verificar dias da semana isolados
        $weekdays = [
            'segunda' => 1,
            'ter√ßa' => 2,
            'terca' => 2,
            'quarta' => 3,
            'quinta' => 4,
            'sexta' => 5,
            's√°bado' => 6,
            'sabado' => 6,
            'domingo' => 0
        ];
        
        foreach ($weekdays as $day => $day_num) {
            if (strpos($message, $day) !== false) {
                $current_day = date('w');
                $days_to_add = ($day_num - $current_day + 7) % 7;
                if ($days_to_add === 0) $days_to_add = 7; // Se for o mesmo dia da semana, pegar pr√≥xima semana
                
                $result['found'] = true;
                $timestamp = strtotime("+$days_to_add days");
                $result['date'] = date('Y-m-d', $timestamp);
                $result['formatted_date'] = date('d/m/Y', $timestamp);
                $result['day_of_week'] = $day_num;
                return $result;
            }
        }
        
        return $result;
    }
    
    /**
     * Extrai informa√ß√µes de hor√°rio de uma mensagem
     * 
     * @param string $message Mensagem do usu√°rio
     * @return array Informa√ß√µes de hor√°rio extra√≠das
     */
    public function extractTimeInfo($message) {
        $message = mb_strtolower(trim($message));
        $result = [
            'found' => false,
            'time' => null,
            'formatted_time' => null
        ];
        
        // Padr√µes de hor√°rio
        $patterns = [
            // HH:MM
            '/(\d{1,2}):(\d{2})/' => function($matches) {
                return sprintf('%02d:%02d:00', $matches[1], $matches[2]);
            },
            // HH:MM:SS
            '/(\d{1,2}):(\d{2}):(\d{2})/' => function($matches) {
                return sprintf('%02d:%02d:%02d', $matches[1], $matches[2], $matches[3]);
            },
            // HHh ou HH horas
            '/(\d{1,2})\s*h(?:oras)?(?!\d)/' => function($matches) {
                return sprintf('%02d:00:00', $matches[1]);
            },
            // HHhMM
            '/(\d{1,2})h(\d{2})/' => function($matches) {
                return sprintf('%02d:%02d:00', $matches[1], $matches[2]);
            }
        ];
        
        // Verificar padr√µes de hor√°rio
        foreach ($patterns as $pattern => $formatter) {
            if (preg_match($pattern, $message, $matches)) {
                $result['found'] = true;
                $result['time'] = $formatter($matches);
                $time_parts = explode(':', $result['time']);
                $result['formatted_time'] = $time_parts[0] . ':' . $time_parts[1];
                return $result;
            }
        }
        
        return $result;
    }
} 